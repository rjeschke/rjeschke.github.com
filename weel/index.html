<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>rjeschke.github.com/weel</title>
<link type="text/css" href="../css/style.css" rel="stylesheet"/>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<meta http-equiv="expires" content="0" />
</head>
<body>
<table class="tmain">
<tr><td class="theader">-- Weel --</td></tr>
<tr><td class="tcontent" style="width: 100%">
<h1>Weel - An extensible scripting language</h1>
<p>Copyright &copy; 2011 Ren√© Jeschke <a href="&#109;a&#105;&#108;&#116;o&#x3a;&#x72;&#101;&#110;&#101;&#95;&#106;e&#115;&#x63;&#104;&#107;&#101;&#64;&#121;&#97;&#x68;&#111;&#x6f;&#x2e;&#100;&#101;">&#x72;&#x65;&#x6e;&#101;&#95;&#106;&#101;&#x73;&#99;&#x68;&#x6b;&#x65;&#64;&#x79;&#97;&#x68;&#x6f;&#x6f;&#46;&#x64;&#101;</a><br />
See LICENSE.txt for licensing information.</p>
<hr />
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#weelruntime">Weel and Runtime</a></li>
<li><a href="#typesandstuff">Types, names and others</a><ul>
<li><a href="#types">Types</a></li>
<li><a href="#names">Names</a></li>
<li><a href="#reservedwords">Reserved words</a></li>
<li><a href="#operators">Operators</a></li>
</ul>
</li>
<li><a href="#flow">Program flow control</a><ul>
<li><a href="#ifelse">if, elseif, else, end</a></li>
<li><a href="#switch">switch, end</a></li>
<li><a href="#for">for, end</a></li>
<li><a href="#foreach">foreach, end</a></li>
<li><a href="#doend">do, end</a></li>
<li><a href="#dountil">do, until</a></li>
<li><a href="#while">while, end</a></li>
</ul>
</li>
<li><a href="#functions">Functions</a></li>
<li><a href="#technical">Technical details</a><ul>
<li><a href="#perft">Performance</a></li>
<li><a href="#stacks">Weel stacks</a></li>
<li><a href="#funccall">Function calling</a></li>
<li><a href="#anonfuncst">Anonymous functions</a></li>
<li><a href="#intnames">Internal function naming</a></li>
<li><a href="#compilation">Compilation</a></li>
</ul>
</li>
<li><a href="#performance">Performance hints</a></li>
</ul>
<hr />
<h3 id="overview">Overview</h3>
<p>Weel is a dynamically typed, stack based programming language running on the
Java&trade; Virtual Machine. Weel source code gets compiled to Java&trade; classes
using a <em>Runtime</em> for its dynamic nature.</p>
<p>Weel &hellip;</p>
<ul>
<li>&hellip; is a simple to learn but powerful language</li>
<li>&hellip; has anonymous functions and closures</li>
<li>&hellip; has type bound dynamic functions <em>(something like mix-ins/traits for
Weel's base types)</em></li>
<li>&hellip; supports multi-threading</li>
<li>&hellip; can export pre-compiled binaries</li>
<li>&hellip; does not depend on any libraries except the Java&trade; runtime</li>
<li>&hellip; can easily be extended by Java&trade; methods</li>
<li>&hellip; has built-in OOP functionality</li>
<li>&hellip; has a built in unit test framework</li>
<li>&hellip; uses UTF-8 for everything string/text related</li>
<li>&hellip; is in some situations even faster than <a href="http://www.lua.org/" title="The Programming Language Lua">Lua</a></li>
</ul>
<hr />
<h3 id="weelruntime">Weel and Runtime</h3>
<p>Weel is separated into two main parts:</p>
<ol>
<li><code>Weel</code> &ndash; The mother class of all runtimes, giving access to a compiler
and holding all global variables and registered functions.</li>
<li><code>Runtime</code> &ndash; The execution environment unique to each thread and mother
<code>Weel</code> instance.</li>
</ol>
<p>With this model it is possible to run Weel functions safely in a
multithreading environment <em>(as long as you don't access global variables)</em>
and to have different 'sets' of Weel instances each having their unique set
of globals and functions.</p>
<p>Weel source code gets compiled 'into' a <code>Weel</code> instance and can then be used
from a <code>Runtime</code> retrieved by <code>Weel.getRuntime()</code>.</p>
<p>Each source file gets internally compiled into its own Java&trade; class.</p>
<p>It is possible to compile new sources into a <code>Weel</code> at any time. This makes
library loading on demand possible <em>(if you only use array or OOP functions
in the library)</em>.</p>
<hr />
<h3 id="typesandstuff">Types, names and others</h3>
<h4 id="types">Types</h4>
<ul>
<li><p>Null: (<code>null</code>)</p>
<pre><code>null
</code></pre>
</li>
<li><p>Strings: (<code>string</code>)</p>
<pre><code>'Hello world'
"Hello world"
'With " inside'
"With ' inside"
"With
line break"
</code></pre>
<p>Allowed escape characters:</p>
<pre><code>\n  \r  \t  \'  \"  \\
</code></pre>
</li>
<li><p>Numbers: (<code>number</code>)</p>
<ul>
<li>Decimal:<pre><code>-10.3
42
1.23e-6
</code></pre>
</li>
<li>Octal:<pre><code>0o777
0O1723
</code></pre>
</li>
<li>Binary:<pre><code>0b11001010
0B111001010101
</code></pre>
</li>
<li>Hexadecimal:<pre><code>0xdeadbeaf
0XCafeBabe
</code></pre>
</li>
</ul>
</li>
<li><p>Maps: (<code>map</code>)</p>
<pre><code>{1, 2, 3, 4};
{"Hello", null, 1, true, println};
{
    [0] = "Test",
    ["key"] = 42,
    name = "Hund",
    arr = {1, 2, 3}
};
{ [0] = "Hello", [1] = "test", [2] = null };
</code></pre>
<p>Internally Weel differentiates between 'list' and 'map', lists are
generally much faster than maps. A list is an ordered map which
contains only consecutive integer keys starting from <code>0</code>. So only
the third map in the code example above is a 'real' map, the others
are lists.</p>
</li>
<li><p>Functions: (<code>function</code>)</p>
<pre><code>a = println
</code></pre>
</li>
<li><p>Objects: (<code>object</code>)</p>
<p>A special type representing a Java Object. This type can't be
directly manipulated from Weel code.</p>
</li>
<li><p>Booleans:</p>
<p>Weel does not have a real boolean type. <code>true</code> evaluates to <code>-1</code> and
<code>false</code> evaluates to <code>0</code>. See below to see how different types and
values map to <code>true</code> and <code>false</code>:</p>
<ul>
<li>Null: is always <code>false</code></li>
<li>Numbers: <code>0.0</code> is <code>false</code>, everything else is <code>true</code></li>
<li>Strings: &ldquo;&rdquo; is <code>false</code>, everything else is <code>true</code></li>
<li>Map: A map with a size of <code>0</code> is <code>false</code>, everything else is <code>true</code></li>
<li>Function: is always <code>true</code></li>
<li>Object: a Java&trade; <code>null</code> value is <code>false</code>, everything else is <code>true</code></li>
</ul>
</li>
</ul>
<h4 id="names">Names</h4>
<ul>
<li>Names are not case sensitive, start with a letter and may contain
letters, digits and <code>_</code></li>
</ul>
<h4 id="operators">Operators</h4>
<ul>
<li><code>+</code> : Addition</li>
<li><code>-</code> : Subtraction</li>
<li><code>*</code> : Multiplication</li>
<li><code>/</code> : Division</li>
<li><code>%</code> : Modulo</li>
<li><code>..</code> : String concatenation</li>
<li><code>++</code> : Map concatenation</li>
<li><code>=</code> : Assign</li>
<li><code>==</code> : Equal</li>
<li><code>!=</code> : Not equal</li>
<li><code>&gt;</code> : Greater than</li>
<li><code>&gt;=</code> : Greater or equal</li>
<li><code>&lt;</code> : Less than</li>
<li><code>&lt;=</code> : Less or equal</li>
<li><code>!</code> : Logical not</li>
<li><code>||</code> : Logical or</li>
<li><code>&amp;&amp;</code> : Logical and</li>
<li><code>~</code> : Binary not</li>
<li><code>&amp;</code> : Binary and</li>
<li><code>|</code> : Binary or</li>
<li><code>^</code> : Binary xor</li>
<li><code>.</code> : Dot (named array indices)</li>
<li><code>:</code> : Colon (declaring OOP functions)</li>
<li><code>::</code> : Double colon (calling type bound functions)</li>
<li><code>-&gt;</code> : Arrow (calling OOP functions)</li>
<li><code>?</code> : Ternary (<code>&lt;cond&gt; ? &lt;expr&gt; : &lt;expr&gt;</code>)</li>
<li><code>+=, -=, *=, /=, %=, &amp;=, |=, ^=, ..=</code></li>
</ul>
<h4 id="reservedwords">Reserved words</h4>
<pre><code>break,
case, continue,
default, do,
else, elseif, end, exit,
false, for, foreach, func,
global,
if, in,
local,
null,
outer,
return,
sub, switch,
then, this, true,
until,
while    
</code></pre>
<hr />
<h3 id="flow">Program flow control</h3>
<h4 id="ifelse">if, elseif, else, end</h4>
<pre><code>if &lt;expr&gt; then
    ...
[elseif &lt;expr&gt; then]
    ...
[else]
    ...
end 
</code></pre>
<p>An <code>if</code> block may contain zero or more <code>elseif</code>s and zero or one <code>else</code>. The
<code>else</code> clause must always be the last.</p>
<h4 id="switch">switch, end</h4>
<pre><code>switch(&lt;expr&gt;)
    [case &lt;expr&gt;:]
        ...
        [break]
    [default:]
        ...
        [break]
end
</code></pre>
<p>A <code>switch</code> block may contain zero or more <code>case</code> statements and zero or one
<code>default</code> statements. <code>default</code> must always be the last statement in a <code>switch</code>
block.</p>
<h4 id="for">for, end</h4>
<pre><code>for &lt;var&gt; = &lt;start-expr&gt;, &lt;end-expr&gt;[, &lt;step-expr&gt;] do
    ...
    [break]
    ...
    [continue]
    ...
end
</code></pre>
<p><code>&lt;var&gt;</code> must be a local variable, if you try to use anything else, a new local
variable with the given name will be created and used.<br />
The loop goes from <code>&lt;start-expr&gt;</code> to (including) <code>&lt;end-expr&gt;</code> with an optional
step (<code>&lt;step-expr&gt;</code>).</p>
<h4 id="foreach">foreach, end</h4>
<pre><code>foreach [&lt;key-var&gt;,]&lt;value-var&gt; in &lt;map-var&gt; do
    ...
    [break]
    ...
    [continue]
    ...
end
</code></pre>
<p>Iterates over the given map.<br /></p>
<h4 id="doend">do, end</h4>
<pre><code>do
    ...
    [break]
    ...
end
</code></pre>
<p>A one-shot loop. Practical as a structured <code>goto</code> replacement and a scope
for local variables.<br /></p>
<h4 id="dountil">do, until</h4>
<pre><code>do
    ...
    [break]
    ...
    [continue]
    ...
until &lt;expr&gt;
</code></pre>
<p>Loops until <code>&lt;expr&gt;</code> evaluates to <code>true</code>.<br /></p>
<h4 id="while">while, end</h4>
<pre><code>while &lt;expr&gt; do
    ...
    [break]
    ...
    [continue]
    ...
end
</code></pre>
<p>Loops while <code>&lt;expr&gt;</code> evaluates to <code>true</code>.<br /></p>
<hr />
<h3 id="functions">Functions</h3>
<p>Weel differentiates between <code>functions</code> <em>(which return a value)</em> and <code>subs</code>
<em>(which don't return a value)</em>:</p>
<h4>Static global functions</h4>
<pre><code>func &lt;name&gt;([&lt;arg-name&gt;[,&lt;arg-name&gt;...]])
    ...
    return &lt;expr&gt;
    ...
end

sub &lt;name&gt;([&lt;arg-name&gt;[,&lt;arg-name&gt;...]])
    ...
    [exit]  // this 'exits' the sub
    ...
end
</code></pre>
<p>Weel supports function overloading for static, array and OOP functions.
The correct function is determined by name and number of arguments. So it
is possible to have an overloaded function taking a differing number of
arguments that returns a value, even if all others don't.</p>
<h4>Anonymous functions</h4>
<pre><code>&lt;expr&gt; = func([&lt;arg-name&gt;[,&lt;arg-name&gt;...]])
    ...
    return &lt;expr&gt;
    ...
end

&lt;expr&gt; = sub([&lt;arg-name&gt;[,&lt;arg-name&gt;...]])
    ...
    [exit]  // this 'exits' the sub
    ...
end
</code></pre>
<p>There's also a shorter syntax available:</p>
<pre><code>&lt;expr&gt; = @{ [(&lt;arg-name&gt;[,&lt;arg-name&gt;...])]
    ...
    return &lt;expr&gt;
    ...
}

&lt;expr&gt; = @{ [(&lt;arg-name&gt;[,&lt;arg-name&gt;...])]
    ...
    [exit]  // this 'exits' the sub
    ...
}
</code></pre>
<p>As you can see you can leave out the argument declaration if you don't use
any arguments, and the syntax for functions and subs is identically.</p>
<h4>Array function examples</h4>
<pre><code>arr = {}

func arr.f()
    return true;
end

arr.g = @{
    println("Hello world!");
}

arr2 = {
    test = 
    @{
        println("Another silly test ...");
    },
    add = 
    @{ (a, b)
        return a + b;
    }
}

arr.g();
println(arr2.add(21, 21));
</code></pre>
<h4>OOP function examples</h4>
<p><em>OOP functions are array functions with some syntactic sugar.</em></p>
<pre><code>clazz = {
    var = "Hello Jim!"
};

sub clazz:print()
    println(this-&gt;var);
end

clazz-&gt;print();

// The above could also be written as:
clazz.print(clazz);
// or:
funcFind("clazz$$print", 1)(clazz);
// or:
createCaller = 
    @{(var)
        return 
            @{
                var-&gt;print();
                // of course you could also use:
                // var.print(var);
                // here.
            };
    };
caller = createCaller(clazz);
caller();
// *cough*
</code></pre>
<h4>A more complex example</h4>
<p><em>This demonstrates the use of type bound functions.</em></p>
<pre><code>// Define our functions (anonymous functions inside a map)
ms = {
    // size()
    size = 
    @{ (m)
        return size(m);
    },
    // fold(f)
    // a generic list fold function
    // for maps we need to use a 'foreach' loop which
    // would make the fold function more complicated
    fold = 
    @{ (list, fc)
        if list == null || size(list) == 0 then
            return null;
        elseif size(list) == 1 then
            return list[0];
        else
            ret = fc(list[0], list[1]);
            for i = 2, size(list) - 1 do
                ret = fc(ret, list[i]);
            end
            return ret;
        end
    }
}

strs = {
    // length()
    length =
    @{ (s)
        return size(s);
    } ,
    // size()
    size =
    @{ (s)
        return size(s);
    } 
}

// Register functions for type 'map'
funcReg("map", ms);
// Register functions for type 'string'
funcReg("string", strs);

// Create a map (well, it's a list)
map = {1, 2, 3, 4};

println(map::size());
// Outputs: 4

println("Result: "..map::fold(@{(a, b) return a + b}));
// Outputs: Result: 10

println({1, 2, 3}::fold(@{(a, b) return a..b}));
// Outputs: 123

println({1, 2, 3}::size());
// Outputs: 3

println("Hello"::size());
// Outputs: 5
</code></pre>
<p><em>This demonstrates 'patching' a library.</em></p>
<pre><code>// Say you've go a console library which defines:

console-&gt;charAt(x, y, ch, col);

// And you want to simplify your life because most of the
// time you use the color `0xff00ff` and don't want to type
// the color every time you call `charAt`.
// Well, simply 'inject' your 'curried' function by putting
// the new function somewhere in your code:

sub concole:charAt(x, y, ch)
    console-&gt;charAt(x, y, ch, 0xff00ff);
end

// and you're done
// A 'dangerous' but very handy possibility to adapt libraries
// to your needs.
</code></pre>
<hr />
<h3 id="technical">Technical details</h3>
<h4 id="perft">Performance</h4>
<p>The reason why I rewrote Yjasl4 was <strong>speed</strong>. After some days of thinking
about the new Weel VM I decided to give direct JVM bytecode generation a try.
The first test, compiling Weel source code by 'hand' as calls to the runtime
in a Java&trade; method showed the potential this approach offered. The speed
increase compared to Yjasl4 is about a factor of 5 to 10, depending on the
code used.</p>
<p>Another benefit of the new compilation method is that I have more freedom to
develop new language features. In Yjasl4 adding a new bytecode could result in
large decrease in performance, so I had to choose wisely which bytecode I <em>really</em>
needed.</p>
<p>In Weel, I can add as many 'bytecodes' as I want, without sacrificing speed (which
already resulted in lots of new features and possibilities).</p>
<p>The main design goals for Weel were/are:</p>
<ul>
<li>Lots of small runtime methods</li>
<li>Minimized number constants storage in class files (not everything gets
really stored as a <code>double</code>)</li>
<li>Avoid object creations wherever possible</li>
<li>Having an API for Java&trade; Weel libraries which also makes it possible
to retrieve the needed value in raw methods without object creations</li>
<li>Multithreading support</li>
</ul>
<p>If you have a look at the runtime class, you won't see many <code>new</code> operators.
Values on the stack get 'copied', not cloned, except for the case when the user
really needs a <code>Value</code>, then I have to clone it. This gives a large speed benefit
but hinders the garbage collector to do its job (because references don't get
removed when changing the type of a value). You can always use <code>Runtime.wipeStack()</code>
to clean unsused references and maybe I'll sacrifice some performance to clean
values when they get 'popped', to minimize the memory footprint.</p>
<h4 id="stacks">Weel stacks</h4>
<ol>
<li><p>The <code>Value</code> stack:</p>
<p>The Value stack is used for all Weel operations. The Runtime avoids costly
Object creations by copying the values inside the stack and only cloning
values if they need to leave the safe space inside the Runtime (e.g. when
calling <code>Runtime.pop()</code>). The Runtime offers also various methods for
library programmers to avoid value cloning by querying a direct value (e.g.
<code>double Runtime.popNumber()</code> or <code>String Runtime.popString()</code>.</p>
</li>
<li><p>The <em>'Frame'</em> stack:</p>
<p>This is used for function frames to prepare function arguments and reserve
space for local variables. In fact it only holds the position of the first
argument or local variable and a frame size.</p>
</li>
<li><p>The <em>'Virtual Function'</em> stack:</p>
<p>This one is used by anonymous functions containing closure variables and
holds a reference to the currently executed function and its closure
variables.</p>
</li>
</ol>
<h4 id="funccall">Function calling</h4>
<p>There are four different types of function calls:</p>
<ol>
<li><p>Static calls:</p>
<p>Every call to a static Weel function or a Java function is a static call
which gets directly compiled into bytecode.</p>
</li>
<li><p>Dynamic calls (aka stack call):</p>
<p>The function to call resides on the stack and has to be called using an
<em>invoker</em> which at the moment uses Reflection to perform its task. As a
dynamic call has every information about the call that it need (name,
number of arguments, and returns-value flag) it can resolve overloaded
functions and prepares the stack to match the situation (e.g. if a
function returns a value and the context doesn't need one the return
value gets discarded).</p>
<p>A stack call only tries to resolve an overloaded function if the expected
argument count does not match the amount defined by the function on the
stack.</p>
</li>
<li><p>Anonymous closure function calls:</p>
<p>These work exactly like stack calls (because they are stack calls) but a
different invoker method is used which registes the function on the
virtual function stack.</p>
</li>
<li><p>Type bound functions:</p>
<p>This is a special type of a stack call, which is always dynamic. The
runtime examines the stack to determine the type to call the function on.
Then it resolves the correct function to call by looking it up using the
type, the name (which is supplied as a String on the JVM stack) and the
number of arguments.</p>
</li>
</ol>
<h4 id="anonfuncst">Anonymous functions</h4>
<p>Anonymous functions are nameless static functions which don't get registered
in the Weel (that's why you can't uses overloading on anonymous functions).</p>
<p>Declaring an anonymous function without closure variables only results in a
Runtime.load(&hellip;) operation, loading the anonymous function (which is already
compiled) by its function index.</p>
<p>This behavious changes when closure variables are needed. Here every expression
which creates such a function also creates a new object with a snapshot of its
used outer variables.</p>
<h4 id="intnames">Internal function naming</h4>
<p>To differentiate between different kinds of functions, three types of function
names are used:</p>
<ol>
<li>Static functions are named as you specified it, so <code>func test(a, b)</code> will
be named <code>test</code>.</li>
<li>Array functions use the name of the array and the function's name
concatenated by <code>$</code>, so <code>func arr.test(a, b)</code> will be named <code>arr$test</code>.</li>
<li>OOP functions use the name of the array and the function's name
concatenated by <code>$$</code>, so <code>func arr:test(a, b)</code> will be named <code>arr$$test</code>.</li>
</ol>
<p>Anonymous functions all use the same static name <code>ANON</code>.</p>
<h4 id="compilation">Compilation</h4>
<p>The Weel compiler does not do any Voodoo, it mostly chains calls to runtime
methods, generates method calls and some IFEQs, IFNEs and GOTOs. It seems
that weel performes so well because of the JIT compiler loving small methods.</p>
<p>So it's all a little bit cheating &hellip; but it works &hellip; and it's fast.</p>
<hr />
<h3 id="performance">Performance hints</h3>
<ul>
<li><p>At the moment static expressions won't result in a static value, so
<code>a = 1 + 2</code> evaluates to <code>a = 1 + 2</code> and not <code>a = 3</code>.</p>
</li>
<li><p>local and closure variables are faster than global variables.</p>
</li>
<li><p><code>a = 2 * b</code> is faster than <code>a = b + b</code>.</p>
</li>
<li><p><code>a += 1</code> is exactly the same as writing <code>a = a + 1</code>, it just is less
characters to type.</p>
</li>
<li><p>a <code>switch</code> is not faster than doing the same with <code>if</code>, <code>elseif</code> and <code>else</code>,
it just looks better.</p>
</li>
<li><p>A Java implementation of a library function might not always be faster than
a pure Weel function when called from Weel code.</p>
</li>
<li><p>If you use overloading with array or OOP functions try to define the
overloaded type you will probably use the most after all other overloading
variations. This will save you some costly runtime overload resolving
operations.</p>
</li>
<li><p>Function calling speed (decreasing from top to bottom):</p>
<ul>
<li>Static Weel/Java function calls</li>
<li>Static Java nice function calls</li>
<li>Dynamic calls</li>
<li>Type bound functions</li>
<li>Dynamic calls with overload resolving</li>
<li>Dynamic calls to closure functions</li>
</ul>
<p>This is currently a good guess, I'll benchmark this as soon as the
rest is stable.</p>
</li>
</ul>
<hr />
<p>Git repository: <a href="https://github.com/rjeschke/weel">https://github.com/rjeschke/weel</a></p>

</td></tr>
<tr><td class="tfooter">&copy; Ren&eacute; Jeschke in 2011</td></tr>
</table>
</body>
</html>
